<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Hand Replayer</title>
    <!-- Add Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">
    <style>
        /* Center and style the main content */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        /* Adjust styles for the poker table and game controls */
        #poker-table {
            text-align: center;
            position: relative;
        }

        #controlPanel {
            margin-top: 80px;
        }

        #label-show-cards {
            color: #fff;
        }
        /* Add this CSS for centering cards and player name/stack */
        .hole-cards-row {
            display: flex;
            justify-content: center; /* Center the cards horizontally */
            align-items: center; /* Center the cards vertically */
        }


        /* Add this CSS to center-align the player's name and stack */
        .player span.badge {
            display: flex;
            justify-content: center; /* Center the cards horizontally */
            align-items: center; /* Center the cards vertically */
            width: auto; /* Allow the badge width to adjust based on content */
            height: auto; /* Allow the badge height to adjust based on content */
        }


        /* Center the player positions */
        .player {
            position: absolute;
            background-color: #007bff;
            color: #fff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
        }
        .card-image-small {
            width: 50px; 
            height: 70px; 
        }
        .hole-cards-row {
            display: flex;
            gap: 0px;
        }

    </style>

</head>
<body class="bg-dark">
    {% set deck_image_url = "/static/backDeck10.svg" %}
    <object id="svgDeck" data={{deck_image_url}} type="image/svg+xml" style="display: none;"></object>
    {% set table_image_url = "/static/TableR.png" %}
<!-- En-tête -->
<div id="header">
    <!-- Contenu de l'en-tête -->
</div>

<!-- Section Centrale -->
<div id="main-section" style="display: flex;">

    <!-- Colonne Gauche (Hand Info) -->
    <div id="left-column" style="flex: 1;">
        <div id="handInfo" class="text-light" style="text-align: left;">
            <span id="heroName">--</span> played Hand n° <span id="handNumber">--</span> on <span id="siteName">--</span> at <span id="tableName">--</span> of <span id="limitType">--</span> <span id="gameType">--</span> with <span id="blinds">--/--</span> <span id="currency">--</span>
        </div>
    </div>

    <!-- Colonne Centrale (Table de Poker et Contrôles) -->
    <div id="center-column" style="flex: 3;">
        <div id="poker-table">
            <img src="{{ table_image_url }}" class="table-image">
        </div>
        <div id="hand" data-hand="{{ hand }}"></div>
        <div id="controlPanel">
            <!-- Boutons et Slider -->
            <input type="range" id="stateSlider">
            <div id="buttonGroup">
                <button type="submit" class="btn btn-secondary" id="prevButton">Prev</button>
                <button type="submit" class="btn btn-secondary" id="startButton">Start</button>
                <button type="submit" class="btn btn-secondary" id="endButton">End</button>
                <button type="submit" class="btn btn-secondary" id="playPauseButton">Play/Pause</button>
                <button type="submit" class="btn btn-secondary" id="nextButton">Next</button>
            </div>
        </div>
        <div id="show-cards-checkbox">
            <label id="label-show-cards">Show Cards</label>
            <input type="checkbox" id="show-cards">
        </div>
    </div>

    <!-- Colonne Droite (Vide pour l'instant) -->
    <div id="right-column" style="flex: 1;">
        <!-- Contenu optionnel -->
    </div>

</div>

<!-- Pied de page -->
<div id="footer">
    <!-- Contenu du pied de page -->
</div>


    <!-- Importation de votre script JavaScript -->
    <script >
// constants

/**
 * Calculates the positions of players around a table based on the number of players.
 *
 * @param {number} numPlayers - The number of players.
 * @returns {Object} - An object containing the x and y positions of each player.
 */
 const players_positions = (numPlayers) => {
    const playerPositions = {};
    const tableWidth = 920; // Adjust the width of your table as needed
    const tableHeight = 560; // Adjust the height of your table as needed

    for (let i = 1; i <= numPlayers; i++) {
        const angle = (i - 1) * (360 / numPlayers);
        const radians = (angle * Math.PI) / 180;
        const x = tableWidth / 2 + tableWidth / 2 * Math.cos(radians);
        const y = tableHeight / 2 + tableHeight / 2 * Math.sin(radians);

        playerPositions[`x${i}`] = x;
        playerPositions[`y${i}`] = y;
    }

    return playerPositions;
}


// Mapping des rangs de cartes pour les images
const rankMap = {
    '2': '2', '3': '3', '4': '4', '5': '5', '6': '6',
    '7': '7', '8': '8', '9': '9', 'T': 't',
    'J': 'j', 'Q': 'q', 'K': 'k', 'A': 'a'
};

// Configuration des différents types de jeux
const games_logic = {
    'holdem': ['hold', 'holdem', 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 2)]],
    '2_holdem': ['hold', null, 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 3)]],
    '6_holdem': ['hold', null, 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 2)]],
    'omahahi': ['hold', 'omaha', 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 4)]],
    'fusion': ['hold', 'fusion', 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 2), (0, 3), (0, 4)]],
    'omahahilo': ['hold', 'omaha8', 's', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 4)]],
    'irish': ['hold', null, 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 4)]],
    '5_omahahi': ['hold', 'omaha', 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 5)]],
    '6_omahahi': ['hold', 'omaha', 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 6)]],
    '5_omaha8': ['hold', 'omaha8', 's', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 5)]],
    '6_omaha8': ['hold', 'omaha8', 's', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 6)]],
    'cour_hi': ['hold', 'omaha', 'h', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 5)]],
    'cour_hilo': ['hold', 'omaha8', 's', {'PREFLOP': 0, 'FLOP': 1, 'TURN': 2, 'RIVER': 3}, 'RIVER', [(0, 5)]],
    'aof_omaha': ['hold', 'omaha', 'h', {'FLOP': 0, 'TURN': 1, 'RIVER': 2}, 'RIVER', [(0, 4)]],
    '5_studhi': ['stud', 'holdem', 'h', {'SECOND': 0, 'THIRD': 1, 'FOURTH': 2, 'FIFTH': 3}, 'FIFTH',
                 [(0, 2), (0, 3), (0, 4), (0, 5)]],
    'razz': ['stud', null, 'l', {'THIRD': 0, 'FOURTH': 1, 'FIFTH': 2, 'SIXTH': 3, 'SEVENTH': 4}, 'SEVENTH',
             [(0, 3), (0, 4), (0, 5), (0, 6), (0, 7)]],
    'studhi': ['stud', '7stud', 'h', {'THIRD': 0, 'FOURTH': 1, 'FIFTH': 2, 'SIXTH': 3, 'SEVENTH': 4}, 'SEVENTH',
               [(0, 3), (0, 4), (0, 5), (0, 6), (0, 7)]],
    'studhilo': ['stud', '7stud8', 's', {'THIRD': 0, 'FOURTH': 1, 'FIFTH': 2, 'SIXTH': 3, 'SEVENTH': 4}, 'SEVENTH',
                 [(0, 3), (0, 4), (0, 5), (0, 6), (0, 7)]],
    '27_3draw': ['draw', 'lowball27', 'r', {'DEAL': 0, 'DRAWONE': 1, 'DRAWTWO': 2, 'DRAWTHREE': 3}, 'DRAWTHREE',
                 [(0, 5), (5, 10), (10, 15), (15, 20)]],
    'fivedraw': ['draw', 'holdem', 'h', {'DEAL': 0, 'DRAWONE': 1}, 'DRAWONE', [(0, 5), (5, 10)]],
    'badugi': ['draw', null, 'l', {'DEAL': 0, 'DRAWONE': 1, 'DRAWTWO': 2, 'DRAWTHREE': 3}, 'DRAWTHREE',
               [(0, 4), (5, 9), (10, 14), (15, 19)]],
    '27_1draw': ['draw', 'lowball27', 'r', {'DEAL': 0, 'DRAWONE': 1}, 'DRAWONE', [(0, 5), (5, 10)]],
    'a5_3draw': ['draw', 'lowball', 'l', {'DEAL': 0, 'DRAWONE': 1, 'DRAWTWO': 2, 'DRAWTHREE': 3}, 'DRAWTHREE',
                 [(0, 5), (5, 10), (10, 15), (15, 20)]],
    'a5_1draw': ['draw', 'lowball', 'l', {'DEAL': 0, 'DRAWONE': 1}, 'DRAWONE', [(0, 5), (5, 10)]],
    '27_razz': ['stud', 'lowball27', 'l', {'THIRD': 0, 'FOURTH': 1, 'FIFTH': 2, 'SIXTH': 3, 'SEVENTH': 4}, 'SEVENTH',
                [(0, 3), (0, 4), (0, 5), (0, 6), (0, 7)]],
    'badacey': ['draw', null, 's', {'DEAL': 0, 'DRAWONE': 1, 'DRAWTWO': 2, 'DRAWTHREE': 3}, 'DRAWTHREE',
                [(0, 5), (5, 10), (10, 15), (15, 20)]],
    'badeucey': ['draw', null, 's', {'DEAL': 0, 'DRAWONE': 1, 'DRAWTWO': 2, 'DRAWTHREE': 3}, 'DRAWTHREE',
                 [(0, 5), (5, 10), (10, 15), (15, 20)]],
    'drawmaha': ['draw', null, 's', {'DEAL': 0, 'DRAWONE': 1, 'DRAWTWO': 2, 'DRAWTHREE': 3}, 'DRAWTHREE',
                 [(0, 5), (5, 10), (10, 15), (15, 20)]]
};


// functions

/**
 * Replaces a card element with a new SVG card from a deck.
 *
 * @param {string} cardElementId - The ID of the card element in the DOM.
 * @param {string} cardDeckId - The ID of the SVG deck containing the card.
 * @returns {void}
 */
 function replaceCard(cardElementId, cardDeckId) {
    // Get the card element in your application's DOM.
    const cardElement = document.getElementById(cardElementId);

    // Get the SVG deck.
    const svgDeck = document.getElementById(cardDeckId);

    // Check if the card element and SVG deck exist.
    if (cardElement && svgDeck) {
        // Get the card from the SVG deck using its ID.
        const svgCard = svgDeck.contentDocument.getElementById(cardElementId);

        if (svgCard) {
            // Clone the SVG card to replace the existing card.
            const clonedCard = svgCard.cloneNode(true);

            // Replace the existing card element with the new SVG card.
            cardElement.parentNode.replaceChild(clonedCard, cardElement);
        }
    }
}


/**
 * Checks the type of a specific game in the games object.
 *
 * @param {Object} games - The games object.
 * @param {string} gameType - The game type to check.
 * @returns {string} - The type of the game ('array', 'string', 'number', 'object', etc.), or 'undefined' if the game type is not found.
 */
 function checkTypeOfGame(games, gameType) {
    if (!games || !games.hasOwnProperty(gameType)) {
        console.error(`game type '${gameType}' not found.`);
        return 'undefined';
    }

    const value = games[gameType][5][0];

    if (Array.isArray(value)) {
        return 'array';
    } else {
        console.log(value);
        return typeof value;  // 'string', 'number', 'object', etc.
    }
}


/**
 * Returns the value at position 5 of a specific game type in the games object.
 *
 * @param {Object} games - The games object.
 * @param {string} gameType - The game type to retrieve the value from.
 * @returns {any} - The value at position 5 of the game type, or null if not found or the structure is not as expected.
 */
 function getPositionFiveValue(games, gameType) {
    if (games && games.hasOwnProperty(gameType)) {
        const gameTypeInfo = games[gameType];
        const gamesType = checkTypeOfGame(games, gameType);
        //console.log("Type de game:", gamesType);
        //console.log(gamesType.toString)
        // Vérification si gameTypeInfo est un tableau et contient l'élément en position 5
        if (Array.isArray(gameTypeInfo) && gameTypeInfo.length > 5) {

            return gameTypeInfo[5][0];
        } else {
            console.error(`'${gameType}' found, but its structure is not as expected.`);
            return null;
        }
    } else {
        console.error(`game type '${gameType}' not found.`);
        return null;
    }
}


/**
 * Joins the hole cards of a player into a string or list format.
 *
 * @param {string} player - The player whose hole cards to join.
 * @param {boolean} [asList=false] - Whether to return the hole cards as a list or a string. Default is false.
 * @returns {string|Array} - The joined hole cards as a string or a list, depending on the value of `asList`.
 */
 function joinHoleCards(player, asList = false) {
    const holeNo = getPositionFiveValue(games_logic, hand.gametype.category);
    console.log("holeNo",holeNo)
    const hcs = new Array(holeNo).fill('0x');

    if (hand.gametype.category == 'fusion') {
        console.log("fusion detected", player);
        for (const street of hand.holeStreets) {
            console.log("fusion street detected", street);
            //console.log("holecards", hand.holecards[street][player]);
            if (hand.holecards[street][player]) {
                console.log("fusion player detected", player);

                if (street === 'PREFLOP') {
                    console.log("fusion PREFLOP detected");
                    if (hand.holecards[street][player][1].length === 1) continue;
                    console.log("fusion PREFLOP detected case 1");
                    for (let i = 0; i < 2; i++) {
                        hcs[i] = hand.holecards[street][player][1][i];
                        hcs[i] = hcs[i].charAt(0).toUpperCase() + hcs[i].slice(1);
                    }
                } 
                else if (street === 'FLOP') {
                    if (hand.holecards[street]['PREFLOP'][1].length === 1) continue;
                        hcs[2] = hand.holecards['PREFLOP'][player][0][0];
                        hcs[2] = hcs[2].charAt(0).toUpperCase() + hcs[2].slice(1);
                } 
                else if (street === 'TURN') {
                    if (hand.holecards['PREFLOP'][player][1].length === 1) continue;
                    hcs[3] = hand.holecards['PREFLOP'][player][0][0];
                    hcs[3] = hcs[3].charAt(0).toUpperCase() + hcs[3].slice(1);
                }
            }
        }
    } else if (hand.gametype.category === 'fivedraw') {
        // Pour le 5 card draw, toutes les cartes sont distribuées dans la street 'DEAL'
        if (player in hand.holecards['DEAL']) {
            const playerCards = hand.holecards['DEAL'][player][1];
            for (let i = 0; i < playerCards.length; i++) {
                hcs[i] = playerCards[i].charAt(0).toUpperCase() + playerCards[i].slice(1);
            }
        }
    } else {
        console.log("game not detected");
        for (const street of hand.holeStreets) {
            if (player in Object.keys(hand.holecards[street])) {
                if (hand.holecards[street][player][1].length === 1) continue;
                for (let i = 0; i < 2; i++) {
                    hcs[i] = hand.holecards[street][player][1][i];
                    hcs[i] = hcs[i].charAt(0).toUpperCase() + hcs[i].slice(1);
                }
                try {
                    for (let i = 2; i < holeNo; i++) {
                        hcs[i] = hand.holecards[street][player][1][i];
                        hcs[i] = hcs[i].charAt(0).toUpperCase() + hcs[i].slice(1);
                    }
                } catch (error) {
                    console.log("Why did we get an index error?");
                }
            }
        }
    }

    if (asList) {
        console.log("Hole cards as list: ", hcs);
        return hcs;
        
    } 
    else {
        console.log("Hole cards as string: ", hcs.join(" "));
        return hcs.join(" ");
        
    }
}



// Classe Player
class Player {
    constructor(hand, name, stack, seat) {
        this.stack = parseFloat(stack);
        this.chips = 0;
        this.seat = seat;
        this.name = name;
        this.action = null;
        this.justacted = false;
        this.holecards = joinHoleCards(name, true);
        this.streetcards = {};




    }

    setAction(action) {
        for (const player of Object.values(this.players)) {
        player.justacted = false;
        }

        this.action = action[1];
        this.justacted = true;

        if (this.action === 'folds' || this.action === 'checks') {
        // Do nothing
        } else if (this.action === 'raises' || this.action === 'bets') {
        if (this.allinThisStreet) {
            this.called = this.bet;
        } else {
            this.called = 0;
        }
        const diff = this.bet - this.chips;
        this.bet += action[2];
        this.chips += action[2] + diff;
        this.stack -= action[2] + diff;
        this.newpot += action[2] + diff;
        } else if (this.action === 'big blind') {
        this.bet = action[2];
        this.chips += action[2];
        this.stack -= action[2];
        this.newpot += action[2];
        } else if (this.action === 'calls' || this.action === 'small blind' || this.action === 'secondsb') {
        this.chips += action[2];
        this.stack -= action[2];
        this.called = Math.max(this.called, this.chips);
        this.newpot += action[2];
        } else if (this.action === 'both') {
        this.chips += action[2];
        this.stack -= action[2];
        this.newpot += action[2];
        } else if (this.action === 'ante') {
        this.pot += action[2];
        this.stack -= action[2];
        this.newpot += action[2];
        } else if (this.action === 'discards') {
        this.action += ' ' + action[2];
        if (action.length > 3) {
            // Must be hero as we have discard information.  Update holecards now.
            this.holecards = this.streetcards[this.street];
        }
        } else if (this.action === 'stands pat') {
        // Do nothing
        } else if (this.action === 'bringin') {
        this.chips += action[2];
        this.stack -= action[2];
        this.newpot += action[2];
        } else {
        console.log('Unhandled action: ' + action);
        }

        if (this.stack === 0) {
        this.allinThisStreet = true;
        }
    }
    }


// class TableState

class TableState {
    constructor(hand) {
        // Initialisations existantes
        this.pot = 0;
        this.street = null;
        this.board = hand.board;
        this.renderBoard = new Set();
        this.bet = 0;
        this.called = 0;
        this.gametype = hand.gametype.category;
        this.gamebase = hand.gametype.base;
        this.allin = false;
        this.allinThisStreet = false;
        this.newpot = 0;

        // Création d'objets Player pour chaque joueur dans la main
        this.players = {};
        for (const items of hand.players) {
            this.players[items[1]] = new Player(hand, items[1], items[2], parseInt(items[0]));
            console.log(this.players[items[1]]);
        }

        // Afficher les informations initiales de la main
        this.displayHandInfo(hand);
    }

    // Méthode pour démarrer une nouvelle phase de jeu
    startPhase(phase) {
        this.street = phase;
        this.newpot = this.newpot;

        // Logique pour gérer le début d'une nouvelle phase
        // ...

        // Afficher les cartes des joueurs pour la phase actuelle
        this.displayPlayerCards(phase);
    }

    // Méthode pour mettre à jour l'état de la table en fonction des actions des joueurs
    updateForAction(action) {
        // Logique pour gérer les actions des joueurs
        // ...

        // Mettre à jour l'affichage après l'action
        this.updateDisplayAfterAction(action);
    }

    // Méthode pour afficher les informations de base de la main
    displayHandInfo(hand) {
        // Affiche des informations de base comme le numéro de la main, les blinds, etc.
        document.getElementById('handNumber').textContent = `${hand.handid}`;
        document.getElementById('blinds').textContent = `${hand.sb}/${hand.bb}`;
        document.getElementById('tableName').textContent = `${hand.tablename}`;
        document.getElementById('siteName').textContent = `${hand.site}`;
        document.getElementById('heroName').textContent = `${hand.hero || 'N/A'}`;
        document.getElementById('limitType').textContent = `${hand.gametype.limitType || 'N/A'}`;
        document.getElementById('gameType').textContent = `${hand.gametype.category || 'N/A'}`;
        document.getElementById('currency').textContent = `${hand.gametype.currency || 'Play money'}`;
    }

    // Méthode pour afficher les cartes des joueurs en fonction de la phase
    displayPlayerCards(phase) {

        const holecards = hand.holecards;
        console.log("holecards", holecards);
        // Determine the number of players from the players object in tablestate
        console.log("hand.players", hand.players); 
        const numPlayers = hand.players.length;
        console.log("numPlayers", numPlayers);
        // Find the maximum seat number
        const maxSeat = Math.max(...Object.values(tableState.players).map(player => player.seat));
        console.log("maxSeat", maxSeat);
        // Calculate missing seats
        const missing_seats = maxSeat - numPlayers;
        console.log("missing_seats", missing_seats);
        // If there are missing seats, adjust the number of players
        if (missing_seats > 0) {
            const numPlayers = maxSeat;
            }


        const playerPositions = players_positions(maxSeat);
        console.log("playerPositions", playerPositions);    
        
        // Loop through each player in tableState.players
        for (let seat = 1; seat <= maxSeat; seat++) {
            // Trouver le joueur qui occupe ce siège
            const player = Object.values(tableState.players).find(p => p.seat === seat);
            console.log("player", player);
            if (player === undefined) {
                console.log(`No player found for seat ${seat}`);
            }
            else {
                let holeCardsHTML = '';

                // Utiliser les holecards du joueur
                if (player.holecards && player.holecards.length > 0) {
                    const cardImages = player.holecards.map(card => {
                        if (card !== '0x') {
                            const rank = rankMap[card[0]];
                            const suit = card[1].toLowerCase();
                            const card_image_url = `/static/fourcolor/${rank}_${suit}.svg`;
                            return `<img src="${card_image_url}" class="card-image-small">`;
                        } else {
                            return '<img src="/static/backDeck10.svg" class="card-image-small">';
                        }
                    });

                    holeCardsHTML = `<div class="hole-cards-row">${cardImages.join('')}</div>`;
                } else {
                    holeCardsHTML = '<div class="hole-cards-row">';
                    for (let i = 0; i < (tableState.gametype === 'omahahi' ? 4 : 2); i++) {
                        holeCardsHTML += '<img src="/static/backDeck10.svg" class="card-image-small">';
                    }
                    holeCardsHTML += '</div>';
                }

                const playerDiv = document.createElement("div");
                playerDiv.classList.add("player", "position-absolute", "text-center");
                // Utiliser la position du joueur calculée
                const positionX = playerPositions[`x${player.seat}`];
                const positionY = playerPositions[`y${player.seat}`];
                playerDiv.style.left = `${positionX}px`;
                playerDiv.style.top = `${positionY}px`;
                playerDiv.innerHTML = `<div>${holeCardsHTML}</div>`;
                playerDiv.innerHTML += `<span class="badge bg-primary">${player.name}<br>${player.stack}</span>`;

                const pokerTable = document.getElementById("poker-table");
                pokerTable.appendChild(playerDiv);
            }
        
        }


    }

    // Méthode pour mettre à jour l'affichage après une action
    updateDisplayAfterAction(action) {
        // Logique pour mettre à jour l'affichage après une action
        // ...
    }
}

// logique du jeu
// Création de l'objet hand à partir des données du jeu
var hand = JSON.parse(document.getElementById("hand").getAttribute("data-hand"));

// Initialisation de l'état de la table avec l'objet hand
const tableState = new TableState(hand);

// Démarrer la première phase du jeu
tableState.startPhase('PREFLOP');

// Gérer les actions des joueurs (ex : un bouton est cliqué pour effectuer une action)





    </script>
</body>
</html>
